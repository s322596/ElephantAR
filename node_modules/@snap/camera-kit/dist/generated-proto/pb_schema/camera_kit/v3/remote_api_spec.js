import Long from "long";
import _m0 from "protobufjs/minimal";
export const protobufPackage = "com.snap.camerakit.v3";
export var RemoteEndpoint_HttpRequestMethod;
(function (RemoteEndpoint_HttpRequestMethod) {
    RemoteEndpoint_HttpRequestMethod[RemoteEndpoint_HttpRequestMethod["METHOD_UNSET"] = 0] = "METHOD_UNSET";
    RemoteEndpoint_HttpRequestMethod[RemoteEndpoint_HttpRequestMethod["GET"] = 1] = "GET";
    RemoteEndpoint_HttpRequestMethod[RemoteEndpoint_HttpRequestMethod["POST"] = 2] = "POST";
    RemoteEndpoint_HttpRequestMethod[RemoteEndpoint_HttpRequestMethod["PUT"] = 3] = "PUT";
    RemoteEndpoint_HttpRequestMethod[RemoteEndpoint_HttpRequestMethod["DELETE"] = 4] = "DELETE";
    RemoteEndpoint_HttpRequestMethod[RemoteEndpoint_HttpRequestMethod["PATCH"] = 5] = "PATCH";
    RemoteEndpoint_HttpRequestMethod[RemoteEndpoint_HttpRequestMethod["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RemoteEndpoint_HttpRequestMethod || (RemoteEndpoint_HttpRequestMethod = {}));
export var RemoteParameter_ParameterLocation;
(function (RemoteParameter_ParameterLocation) {
    RemoteParameter_ParameterLocation[RemoteParameter_ParameterLocation["LOCATION_UNSET"] = 0] = "LOCATION_UNSET";
    RemoteParameter_ParameterLocation[RemoteParameter_ParameterLocation["QUERY"] = 1] = "QUERY";
    RemoteParameter_ParameterLocation[RemoteParameter_ParameterLocation["HEADER"] = 2] = "HEADER";
    RemoteParameter_ParameterLocation[RemoteParameter_ParameterLocation["PATH"] = 3] = "PATH";
    RemoteParameter_ParameterLocation[RemoteParameter_ParameterLocation["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RemoteParameter_ParameterLocation || (RemoteParameter_ParameterLocation = {}));
function createBaseGetRemoteApiSpecsRequest() {
    return {};
}
export const GetRemoteApiSpecsRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetRemoteApiSpecsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(_) {
        const message = createBaseGetRemoteApiSpecsRequest();
        return message;
    },
};
function createBaseGetRemoteApiSpecsResponse() {
    return { remoteApiSpecs: [] };
}
export const GetRemoteApiSpecsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.remoteApiSpecs) {
            RemoteApiSpec.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetRemoteApiSpecsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.remoteApiSpecs.push(RemoteApiSpec.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseGetRemoteApiSpecsResponse();
        message.remoteApiSpecs = ((_a = object.remoteApiSpecs) === null || _a === void 0 ? void 0 : _a.map((e) => RemoteApiSpec.fromPartial(e))) || [];
        return message;
    },
};
function createBaseRemoteApiSpec() {
    return {
        id: "",
        host: "",
        endpoints: [],
        tlsRequired: false,
        maxRequestSizeBytes: 0,
        maxResponseSizeBytes: 0,
        maxResponseTimeMillis: 0,
    };
}
export const RemoteApiSpec = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.host !== "") {
            writer.uint32(18).string(message.host);
        }
        for (const v of message.endpoints) {
            RemoteEndpoint.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.tlsRequired === true) {
            writer.uint32(32).bool(message.tlsRequired);
        }
        if (message.maxRequestSizeBytes !== 0) {
            writer.uint32(40).int32(message.maxRequestSizeBytes);
        }
        if (message.maxResponseSizeBytes !== 0) {
            writer.uint32(48).int32(message.maxResponseSizeBytes);
        }
        if (message.maxResponseTimeMillis !== 0) {
            writer.uint32(56).int32(message.maxResponseTimeMillis);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoteApiSpec();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.host = reader.string();
                    break;
                case 3:
                    message.endpoints.push(RemoteEndpoint.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.tlsRequired = reader.bool();
                    break;
                case 5:
                    message.maxRequestSizeBytes = reader.int32();
                    break;
                case 6:
                    message.maxResponseSizeBytes = reader.int32();
                    break;
                case 7:
                    message.maxResponseTimeMillis = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseRemoteApiSpec();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.host = (_b = object.host) !== null && _b !== void 0 ? _b : "";
        message.endpoints = ((_c = object.endpoints) === null || _c === void 0 ? void 0 : _c.map((e) => RemoteEndpoint.fromPartial(e))) || [];
        message.tlsRequired = (_d = object.tlsRequired) !== null && _d !== void 0 ? _d : false;
        message.maxRequestSizeBytes = (_e = object.maxRequestSizeBytes) !== null && _e !== void 0 ? _e : 0;
        message.maxResponseSizeBytes = (_f = object.maxResponseSizeBytes) !== null && _f !== void 0 ? _f : 0;
        message.maxResponseTimeMillis = (_g = object.maxResponseTimeMillis) !== null && _g !== void 0 ? _g : 0;
        return message;
    },
};
function createBaseRemoteEndpoint() {
    return { path: "", methods: [], parameters: [], refId: "" };
}
export const RemoteEndpoint = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.path !== "") {
            writer.uint32(10).string(message.path);
        }
        writer.uint32(18).fork();
        for (const v of message.methods) {
            writer.int32(v);
        }
        writer.ldelim();
        for (const v of message.parameters) {
            RemoteParameter.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.refId !== "") {
            writer.uint32(34).string(message.refId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoteEndpoint();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.path = reader.string();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.methods.push(reader.int32());
                        }
                    }
                    else {
                        message.methods.push(reader.int32());
                    }
                    break;
                case 3:
                    message.parameters.push(RemoteParameter.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.refId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseRemoteEndpoint();
        message.path = (_a = object.path) !== null && _a !== void 0 ? _a : "";
        message.methods = ((_b = object.methods) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];
        message.parameters = ((_c = object.parameters) === null || _c === void 0 ? void 0 : _c.map((e) => RemoteParameter.fromPartial(e))) || [];
        message.refId = (_d = object.refId) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseRemoteParameter() {
    return { name: "", location: 0, optional: false, externalName: "", defaultValue: "", constant: false };
}
export const RemoteParameter = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.location !== 0) {
            writer.uint32(16).int32(message.location);
        }
        if (message.optional === true) {
            writer.uint32(24).bool(message.optional);
        }
        if (message.externalName !== "") {
            writer.uint32(34).string(message.externalName);
        }
        if (message.defaultValue !== "") {
            writer.uint32(42).string(message.defaultValue);
        }
        if (message.constant === true) {
            writer.uint32(48).bool(message.constant);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRemoteParameter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.location = reader.int32();
                    break;
                case 3:
                    message.optional = reader.bool();
                    break;
                case 4:
                    message.externalName = reader.string();
                    break;
                case 5:
                    message.defaultValue = reader.string();
                    break;
                case 6:
                    message.constant = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseRemoteParameter();
        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
        message.location = (_b = object.location) !== null && _b !== void 0 ? _b : 0;
        message.optional = (_c = object.optional) !== null && _c !== void 0 ? _c : false;
        message.externalName = (_d = object.externalName) !== null && _d !== void 0 ? _d : "";
        message.defaultValue = (_e = object.defaultValue) !== null && _e !== void 0 ? _e : "";
        message.constant = (_f = object.constant) !== null && _f !== void 0 ? _f : false;
        return message;
    },
};
export const RemoteApiSpecsDefinition = {
    name: "RemoteApiSpecs",
    fullName: "com.snap.camerakit.v3.RemoteApiSpecs",
    methods: {
        getRemoteApiSpecs: {
            name: "GetRemoteApiSpecs",
            requestType: GetRemoteApiSpecsRequest,
            requestStream: false,
            responseType: GetRemoteApiSpecsResponse,
            responseStream: false,
            options: {
                idempotencyLevel: "NO_SIDE_EFFECTS",
            },
        },
    },
};
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
//# sourceMappingURL=remote_api_spec.js.map